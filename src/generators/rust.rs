use std::{fmt::Write, path::PathBuf};

use crate::{
    ast::{Definition, EnumDef, Field, OnyxModule, PrimitiveType, Type, WireEndianness},
    generators::{CodeGenerator, CompileError},
};

/// Configuration settings specific to Rust code generation
#[derive(Debug, Clone)]
pub struct RustConfig {
    /// Number of spaces to use for each indentation level.
    pub indent_spaces: usize,
}

impl Default for RustConfig {
    fn default() -> Self {
        RustConfig { indent_spaces: 4 }
    }
}

impl RustConfig {
    pub fn get_indent(&self, num: usize) -> String {
        " ".repeat(self.indent_spaces * num)
    }
}

#[derive(Debug, Default)]
/// The Rust code generator.
///
/// Generates a Rust source file (.rs) for the given Onyx module.
pub struct RustGenerator {
    config: RustConfig,
    output: String,
    file_path: PathBuf,
    file_stem: String,
}

impl RustGenerator {
    /// Adds a file path to the generator configuration.
    pub fn add_file_path(&mut self, file_path: PathBuf) -> Result<(), CompileError> {
        self.file_path = file_path;
        self.file_stem = match self.file_path.file_stem() {
            Some(s) => s.to_string_lossy().to_string(),
            None => return Err(CompileError(String::new())),
        };
        Ok(())
    }

    /// Maps Onyx PrimitiveType to Rust type strings.
    fn map_primitive_type_to_rust(&self, p: &PrimitiveType) -> &'static str {
        match p {
            PrimitiveType::Bool => "bool",
            PrimitiveType::U8 => "u8",
            PrimitiveType::U16 => "u16",
            PrimitiveType::U32 => "u32",
            PrimitiveType::U64 => "u64",
            PrimitiveType::I8 => "i8",
            PrimitiveType::I16 => "i16",
            PrimitiveType::I32 => "i32",
            PrimitiveType::I64 => "i64",
            PrimitiveType::F32 => "f32",
            PrimitiveType::F64 => "f64",
        }
    }

    fn get_primitive_rust_type(&self, type_info: &Type) -> String {
        match type_info {
            Type::Primitive(p) => self.map_primitive_type_to_rust(p).to_string(),
            Type::Custom(s) => s.clone(),
        }
    }

    fn get_field_groups<'a>(&self, fields: &'a Vec<Field>) -> Vec<Vec<&'a Field>> {
        let mut field_groups: Vec<Vec<&Field>> = Vec::new();
        let mut current_group: Vec<&Field> = Vec::new();

        for field in fields {
            if field.bit_field_size.is_some() {
                // Group consecutive bit-fields
                current_group.push(field);
            } else {
                // Non-bit-field encountered. Process the current group, then the standalone field.
                if !current_group.is_empty() {
                    field_groups.push(std::mem::take(&mut current_group));
                }
                field_groups.push(vec![field]); // Non-bit-field is a group of size 1
            }
        }
        if !current_group.is_empty() {
            field_groups.push(current_group);
        }
        field_groups
    }

    fn get_serialized_size(&self, module: &OnyxModule, def: &Definition) -> usize {
        match def {
            Definition::Enum(e) => e.underlying_type.get_bit_width() / 8,
            Definition::Struct(s) => self.get_fields_size(module, &s.fields),
            Definition::Message(m) => self.get_fields_size(module, &m.fields),
        }
    }

    fn get_fields_size(&self, module: &OnyxModule, fields: &Vec<Field>) -> usize {
        let groups = self.get_field_groups(fields);
        let mut size = 0;
        for group in groups {
            let first_field = group[0];
            if group.len() > 1 || first_field.bit_field_size.is_some() {
                let mut container_bits = 0;
                for field in group {
                    container_bits += field.get_bit_width(module);
                }
                size += container_bits.div_ceil(8);
            } else {
                match &first_field.type_info {
                    Type::Primitive(p) => size += p.get_bit_width() / 8,
                    Type::Custom(name) => {
                        if let Some(def) = module.definitions.get(name) {
                            size += self.get_serialized_size(module, def);
                        }
                    }
                }
            }
        }
        size
    }

    fn write_header(&mut self) {
        writeln!(
            self.output,
            "// Automatically generated by Onyx IDL compiler"
        )
        .unwrap();
        writeln!(self.output, "\nuse std::convert::TryInto;\n").unwrap();
    }

    fn write_enum(&mut self, e: &EnumDef) -> Result<(), CompileError> {
        let underlying_type = self.map_primitive_type_to_rust(&e.underlying_type);
        writeln!(self.output, "#[repr({underlying_type})]").unwrap();
        writeln!(self.output, "#[derive(Debug, Clone, Copy, PartialEq, Eq)]").unwrap();
        writeln!(self.output, "pub enum {} {{", e.name).unwrap();

        let mut current_value: u64 = 0;
        for variant in &e.variants {
            let assigned_value = if let Some(val) = variant.value {
                current_value = val + 1;
                format!(" = {val}")
            } else {
                let val = current_value;
                current_value += 1;
                format!(" = {val}")
            };
            writeln!(
                self.output,
                "{}{}{},",
                self.config.get_indent(1),
                variant.name,
                assigned_value
            )
            .unwrap();
        }
        writeln!(self.output, "}}").unwrap();

        // Implement Default for Enum (first variant)
        if let Some(first) = e.variants.first() {
            writeln!(self.output, "\nimpl Default for {} {{", e.name).unwrap();
            writeln!(
                self.output,
                "{}fn default() -> Self {{",
                self.config.get_indent(1)
            )
            .unwrap();
            writeln!(
                self.output,
                "{}Self::{}",
                self.config.get_indent(2),
                first.name
            )
            .unwrap();
            writeln!(self.output, "{}}}", self.config.get_indent(1)).unwrap();
            writeln!(self.output, "}}").unwrap();
        }

        Ok(())
    }

    fn write_view_structs(
        &mut self,
        struct_name: &String,
        field_groups: &Vec<Vec<&Field>>,
        module: &OnyxModule,
        def: &Definition,
    ) {
        let const_struct_name = struct_name.to_ascii_uppercase();
        let size = self.get_serialized_size(module, def);

        writeln!(self.output, "\n/// Size of {struct_name} in bytes.").unwrap();
        writeln!(
            self.output,
            "const {const_struct_name}_SIZE: usize = {size};"
        )
        .unwrap();

        // Buffer type alias
        writeln!(self.output, "/// Buffer type alias for {struct_name}.").unwrap();
        writeln!(
            self.output,
            "pub type {struct_name}Buffer = [u8; {const_struct_name}_SIZE];"
        )
        .unwrap();

        // View (Read-only)
        writeln!(self.output, "\n/// Read-only view of {struct_name}.").unwrap();
        writeln!(self.output, "#[derive(Debug, Clone, Copy)]").unwrap();
        writeln!(self.output, "pub struct {struct_name}View<'a> {{").unwrap();
        writeln!(
            self.output,
            "{}data: &'a {}Buffer,",
            self.config.get_indent(1),
            struct_name
        )
        .unwrap();
        writeln!(self.output, "}}").unwrap();

        // MutView (Read-Write)
        writeln!(self.output, "\n/// Read-write view of {struct_name}.").unwrap();
        writeln!(self.output, "#[derive(Debug)]").unwrap();
        writeln!(self.output, "pub struct {struct_name}MutView<'a> {{").unwrap();
        writeln!(
            self.output,
            "{}data: &'a mut {}Buffer,",
            self.config.get_indent(1),
            struct_name
        )
        .unwrap();
        writeln!(self.output, "}}").unwrap();

        // Impl View
        writeln!(self.output, "\nimpl<'a> {struct_name}View<'a> {{").unwrap();

        writeln!(
            self.output,
            "{}/// Creates a new {struct_name}View from a {struct_name}Buffer.",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.output,
            "{}pub fn new(data: &'a {}Buffer) -> Self {{",
            self.config.get_indent(1),
            struct_name
        )
        .unwrap();
        writeln!(self.output, "{}Self {{ data }}", self.config.get_indent(2)).unwrap();
        writeln!(self.output, "{}}}", self.config.get_indent(1)).unwrap();

        self.write_accessors(field_groups, module, false);
        writeln!(self.output, "}}").unwrap();

        // Impl MutView
        writeln!(self.output, "\nimpl<'a> {struct_name}MutView<'a> {{").unwrap();

        writeln!(
            self.output,
            "{}/// Creates a new {struct_name}MutView from a {struct_name}Buffer.",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.output,
            "{}pub fn new(data: &'a mut {}Buffer) -> Self {{",
            self.config.get_indent(1),
            struct_name
        )
        .unwrap();
        writeln!(self.output, "{}Self {{ data }}", self.config.get_indent(2)).unwrap();
        writeln!(self.output, "{}}}", self.config.get_indent(1)).unwrap();

        self.write_accessors(field_groups, module, true);
        writeln!(self.output, "}}").unwrap();
    }

    fn write_accessors(
        &mut self,
        field_groups: &Vec<Vec<&Field>>,
        module: &OnyxModule,
        is_mut: bool,
    ) {
        let from_method = match module.endianness {
            WireEndianness::Big => "from_be_bytes",
            WireEndianness::Little => "from_le_bytes",
        };
        let to_method = match module.endianness {
            WireEndianness::Big => "to_be_bytes",
            WireEndianness::Little => "to_le_bytes",
        };

        let mut current_offset = 0;

        for group in field_groups {
            let first_field = group[0];

            if group.len() > 1 || first_field.bit_field_size.is_some() {
                // Bit-field group
                let mut container_bits = 0;
                for field in group {
                    container_bits += field.get_bit_width(module);
                }
                let container_bytes = container_bits.div_ceil(8);

                self.write_bitfield_accessors(
                    group,
                    current_offset,
                    container_bytes,
                    is_mut,
                    from_method,
                    to_method,
                );
                current_offset += container_bytes;
            } else {
                // Regular field
                let field = first_field;
                let type_str = self.get_primitive_rust_type(&field.type_info);

                match &field.type_info {
                    Type::Primitive(p) => {
                        let size = p.get_bit_width() / 8;
                        let rust_type = self.map_primitive_type_to_rust(p);

                        // Accessor
                        writeln!(
                            self.output,
                            "\n{}/// Accessor for {}.",
                            self.config.get_indent(1),
                            field.name
                        )
                        .unwrap();
                        writeln!(
                            self.output,
                            "{}pub fn {}(&self) -> {} {{",
                            self.config.get_indent(1),
                            field.name,
                            type_str
                        )
                        .unwrap();

                        if rust_type == "u8" || rust_type == "i8" {
                            writeln!(
                                self.output,
                                "{}self.data[{}] as {}",
                                self.config.get_indent(2),
                                current_offset,
                                rust_type
                            )
                            .unwrap();
                        } else if rust_type == "bool" {
                            writeln!(
                                self.output,
                                "{}self.data[{}] != 0",
                                self.config.get_indent(2),
                                current_offset
                            )
                            .unwrap();
                        } else {
                            writeln!(
                                self.output,
                                "{}let bytes = self.data[{}..{}].try_into().unwrap();",
                                self.config.get_indent(2),
                                current_offset,
                                current_offset + size
                            )
                            .unwrap();
                            writeln!(
                                self.output,
                                "{}{}::{}(bytes)",
                                self.config.get_indent(2),
                                rust_type,
                                from_method
                            )
                            .unwrap();
                        }
                        writeln!(self.output, "{}}}", self.config.get_indent(1)).unwrap();

                        // Mutator (only if mutable)
                        if is_mut {
                            writeln!(
                                self.output,
                                "\n{}/// Mutator for {}.",
                                self.config.get_indent(1),
                                field.name
                            )
                            .unwrap();
                            writeln!(
                                self.output,
                                "{}pub fn set_{}(&mut self, value: {}) {{",
                                self.config.get_indent(1),
                                field.name,
                                type_str
                            )
                            .unwrap();

                            if rust_type == "u8" || rust_type == "i8" {
                                writeln!(
                                    self.output,
                                    "{}self.data[{}] = value as u8;",
                                    self.config.get_indent(2),
                                    current_offset
                                )
                                .unwrap();
                            } else if rust_type == "bool" {
                                writeln!(
                                    self.output,
                                    "{}self.data[{}] = if value {{ 1 }} else {{ 0 }};",
                                    self.config.get_indent(2),
                                    current_offset
                                )
                                .unwrap();
                            } else {
                                writeln!(
                                    self.output,
                                    "{}let bytes = value.{}();",
                                    self.config.get_indent(2),
                                    to_method
                                )
                                .unwrap();
                                writeln!(
                                    self.output,
                                    "{}self.data[{}..{}].copy_from_slice(&bytes);",
                                    self.config.get_indent(2),
                                    current_offset,
                                    current_offset + size
                                )
                                .unwrap();
                            }
                            writeln!(self.output, "{}}}", self.config.get_indent(1)).unwrap();
                        }

                        current_offset += size;
                    }
                    Type::Custom(s) => {
                        if let Some(def) = module.definitions.get(s) {
                            match def {
                                Definition::Struct(_) | Definition::Message(_) => {
                                    let size = self.get_serialized_size(module, def);

                                    // Accessor returns View
                                    writeln!(
                                        self.output,
                                        "\n{}/// Accessor for {}.",
                                        self.config.get_indent(1),
                                        field.name
                                    )
                                    .unwrap();
                                    writeln!(
                                        self.output,
                                        "{}pub fn {}(&self) -> {}View {{",
                                        self.config.get_indent(1),
                                        field.name,
                                        s
                                    )
                                    .unwrap();
                                    writeln!(
                                        self.output,
                                        "{}let slice = &self.data[{}..{}];",
                                        self.config.get_indent(2),
                                        current_offset,
                                        current_offset + size
                                    )
                                    .unwrap();
                                    writeln!(
                                        self.output,
                                        "{}{}View::new(slice.try_into().unwrap())",
                                        self.config.get_indent(2),
                                        s
                                    )
                                    .unwrap();
                                    writeln!(self.output, "{}}}", self.config.get_indent(1))
                                        .unwrap();

                                    // Mutable accessor returns MutView (only if mutable)
                                    if is_mut {
                                        writeln!(
                                            self.output,
                                            "\n{}/// Mutable accessor for {}.",
                                            self.config.get_indent(1),
                                            field.name
                                        )
                                        .unwrap();
                                        writeln!(
                                            self.output,
                                            "{}pub fn {}_mut(&mut self) -> {}MutView {{",
                                            self.config.get_indent(1),
                                            field.name,
                                            s
                                        )
                                        .unwrap();
                                        writeln!(
                                            self.output,
                                            "{}let slice = &mut self.data[{}..{}];",
                                            self.config.get_indent(2),
                                            current_offset,
                                            current_offset + size
                                        )
                                        .unwrap();
                                        writeln!(
                                            self.output,
                                            "{}{}MutView::new(slice.try_into().unwrap())",
                                            self.config.get_indent(2),
                                            s
                                        )
                                        .unwrap();
                                        writeln!(self.output, "{}}}", self.config.get_indent(1))
                                            .unwrap();
                                    }
                                    current_offset += size;
                                }
                                Definition::Enum(e) => {
                                    let size = e.underlying_type.get_bit_width() / 8;
                                    let underlying =
                                        self.map_primitive_type_to_rust(&e.underlying_type);

                                    // Accessor
                                    writeln!(
                                        self.output,
                                        "\n{}/// Accessor for {}.",
                                        self.config.get_indent(1),
                                        field.name
                                    )
                                    .unwrap();
                                    writeln!(
                                        self.output,
                                        "{}pub fn {}(&self) -> {} {{",
                                        self.config.get_indent(1),
                                        field.name,
                                        s
                                    )
                                    .unwrap();

                                    writeln!(
                                        self.output,
                                        "{}let bytes = self.data[{}..{}].try_into().unwrap();",
                                        self.config.get_indent(2),
                                        current_offset,
                                        current_offset + size
                                    )
                                    .unwrap();
                                    writeln!(
                                        self.output,
                                        "{}let val = {}::{}(bytes);",
                                        self.config.get_indent(2),
                                        underlying,
                                        from_method
                                    )
                                    .unwrap();
                                    writeln!(
                                        self.output,
                                        "{}unsafe {{ std::mem::transmute(val) }}",
                                        self.config.get_indent(2)
                                    )
                                    .unwrap();
                                    writeln!(self.output, "{}}}", self.config.get_indent(1))
                                        .unwrap();

                                    // Mutator
                                    if is_mut {
                                        writeln!(
                                            self.output,
                                            "\n{}/// Mutator for {}.",
                                            self.config.get_indent(1),
                                            field.name
                                        )
                                        .unwrap();
                                        writeln!(
                                            self.output,
                                            "{}pub fn set_{}(&mut self, value: {}) {{",
                                            self.config.get_indent(1),
                                            field.name,
                                            s
                                        )
                                        .unwrap();
                                        writeln!(
                                            self.output,
                                            "{}let val = value as {};",
                                            self.config.get_indent(2),
                                            underlying
                                        )
                                        .unwrap();
                                        writeln!(
                                            self.output,
                                            "{}let bytes = val.{}();",
                                            self.config.get_indent(2),
                                            to_method
                                        )
                                        .unwrap();
                                        writeln!(
                                            self.output,
                                            "{}self.data[{}..{}].copy_from_slice(&bytes);",
                                            self.config.get_indent(2),
                                            current_offset,
                                            current_offset + size
                                        )
                                        .unwrap();
                                        writeln!(self.output, "{}}}", self.config.get_indent(1))
                                            .unwrap();
                                    }
                                    current_offset += size;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    fn write_bitfield_accessors(
        &mut self,
        group: &Vec<&Field>,
        offset: usize,
        container_bytes: usize,
        is_mut: bool,
        from_method: &str,
        to_method: &str,
    ) {
        let mut current_bit_offset: usize = 0;
        let int_type = match container_bytes {
            1 => "u8",
            2 => "u16",
            4 => "u32",
            8 => "u64",
            _ => "u128",
        };

        for field in group {
            let field_type_str = self.get_primitive_rust_type(&field.type_info);
            let bits = field.bit_field_size.unwrap_or(0);
            let mask = (1u64 << bits).saturating_sub(1);
            let shift = current_bit_offset;

            // Accessor
            writeln!(
                self.output,
                "\n{}/// Accessor for {}.",
                self.config.get_indent(1),
                field.name
            )
            .unwrap();
            writeln!(
                self.output,
                "{}pub fn {}(&self) -> {} {{",
                self.config.get_indent(1),
                field.name,
                field_type_str
            )
            .unwrap();

            // Read container
            if container_bytes == 1 {
                writeln!(
                    self.output,
                    "{}let raw = self.data[{}] as {};",
                    self.config.get_indent(2),
                    offset,
                    int_type
                )
                .unwrap();
            } else {
                writeln!(
                    self.output,
                    "{}let bytes = self.data[{}..{}].try_into().unwrap();",
                    self.config.get_indent(2),
                    offset,
                    offset + container_bytes
                )
                .unwrap();
                writeln!(
                    self.output,
                    "{}let raw = {}::{}(bytes);",
                    self.config.get_indent(2),
                    int_type,
                    from_method
                )
                .unwrap();
            }

            writeln!(
                self.output,
                "{}let val = (raw >> {}) & 0x{:X};",
                self.config.get_indent(2),
                shift,
                mask
            )
            .unwrap();

            if field_type_str == "bool" {
                writeln!(self.output, "{}val != 0", self.config.get_indent(2)).unwrap();
            } else {
                writeln!(
                    self.output,
                    "{}val as {}",
                    self.config.get_indent(2),
                    field_type_str
                )
                .unwrap();
            }
            writeln!(self.output, "{}}}", self.config.get_indent(1)).unwrap();

            // Mutator
            if is_mut {
                writeln!(
                    self.output,
                    "\n{}/// Mutator for {}.",
                    self.config.get_indent(1),
                    field.name
                )
                .unwrap();
                writeln!(
                    self.output,
                    "{}pub fn set_{}(&mut self, value: {}) {{",
                    self.config.get_indent(1),
                    field.name,
                    field_type_str
                )
                .unwrap();

                // Read container
                if container_bytes == 1 {
                    writeln!(
                        self.output,
                        "{}let mut raw = self.data[{}] as {};",
                        self.config.get_indent(2),
                        offset,
                        int_type
                    )
                    .unwrap();
                } else {
                    writeln!(
                        self.output,
                        "{}let bytes = self.data[{}..{}].try_into().unwrap();",
                        self.config.get_indent(2),
                        offset,
                        offset + container_bytes
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "{}let mut raw = {}::{}(bytes);",
                        self.config.get_indent(2),
                        int_type,
                        from_method
                    )
                    .unwrap();
                }

                // Modify
                writeln!(
                    self.output,
                    "{}raw &= !((0x{:X} as {}) << {});",
                    self.config.get_indent(2),
                    mask,
                    int_type,
                    shift
                )
                .unwrap();
                writeln!(
                    self.output,
                    "{}raw |= ((value as {} & 0x{:X}) as {}) << {};",
                    self.config.get_indent(2),
                    int_type,
                    mask,
                    int_type,
                    shift
                )
                .unwrap();

                // Write back
                if container_bytes == 1 {
                    writeln!(
                        self.output,
                        "{}self.data[{}] = raw as u8;",
                        self.config.get_indent(2),
                        offset
                    )
                    .unwrap();
                } else {
                    writeln!(
                        self.output,
                        "{}let bytes = raw.{}();",
                        self.config.get_indent(2),
                        to_method
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "{}self.data[{}..{}].copy_from_slice(&bytes);",
                        self.config.get_indent(2),
                        offset,
                        offset + container_bytes
                    )
                    .unwrap();
                }
                writeln!(self.output, "{}}}", self.config.get_indent(1)).unwrap();
            }

            current_bit_offset += bits;
        }
    }
}

impl CodeGenerator for RustGenerator {
    fn generate(&mut self, module: &OnyxModule) -> Result<Vec<(PathBuf, String)>, CompileError> {
        self.output.clear();
        self.write_header();

        for name in &module.order {
            if let Some(def) = module.definitions.get(name) {
                match def {
                    Definition::Enum(e) => self.write_enum(e)?,
                    Definition::Struct(s) => {
                        let field_groups = self.get_field_groups(&s.fields);
                        self.write_view_structs(&s.name, &field_groups, module, def);
                    }
                    Definition::Message(m) => {
                        let field_groups = self.get_field_groups(&m.fields);
                        self.write_view_structs(&m.name, &field_groups, module, def);
                    }
                }
            }
        }

        let mut output_path = self.file_path.clone();
        output_path.set_extension("rs");

        Ok(vec![(output_path, self.output.clone())])
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rust_config_indent() {
        let config = RustConfig::default();
        assert_eq!(config.get_indent(1), "    ");
        assert_eq!(config.get_indent(2), "        ");
    }

    #[test]
    fn test_primitive_mapping() {
        let generator = RustGenerator::default();
        assert_eq!(
            generator.map_primitive_type_to_rust(&PrimitiveType::U8),
            "u8"
        );
        assert_eq!(
            generator.map_primitive_type_to_rust(&PrimitiveType::I32),
            "i32"
        );
        assert_eq!(
            generator.map_primitive_type_to_rust(&PrimitiveType::F64),
            "f64"
        );
    }
}
