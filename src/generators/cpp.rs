use std::{collections::HashMap, fmt::Write};

use crate::{
    ast::{Definition, EnumDef, MessageDef, OnyxModule, PrimitiveType, StructDef, Type},
    generators::{CodeGenerator, CompileError},
};

pub struct CppGenerator {
    header_output: String,
    source_output: String,
    pub file_stem: String,
}

impl Default for CppGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl CppGenerator {
    pub fn new() -> Self {
        CppGenerator {
            header_output: String::new(),
            source_output: String::new(),
            file_stem: String::new(),
        }
    }

    /// Maps Onyx PrimitiveType to C++ type strings.
    fn map_primitive_type_to_cpp(&self, p: &PrimitiveType) -> &'static str {
        match p {
            PrimitiveType::Bool => "bool",
            PrimitiveType::U8 => "uint8_t",
            PrimitiveType::U16 => "uint16_t",
            PrimitiveType::U32 => "uint32_t",
            PrimitiveType::U64 => "uint64_t",
            PrimitiveType::I8 => "int8_t",
            PrimitiveType::I16 => "int16_t",
            PrimitiveType::I32 => "int32_t",
            PrimitiveType::I64 => "int64_t",
            PrimitiveType::F32 => "float",
            PrimitiveType::F64 => "double",
        }
    }

    fn write_header_includes(&mut self) {
        writeln!(
            self.header_output,
            "// Automatically generated by Onyx IDL compiler"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#ifndef ONYX_{}_H_",
            self.file_stem.to_ascii_uppercase()
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#define ONYX_{}_H_\n",
            self.file_stem.to_ascii_uppercase()
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#include <cstdint> // For fixed-size integers (uint8_t, etc.)"
        )
        .unwrap();
        writeln!(self.header_output, "#include <cstring> // For size_t\n").unwrap();
        writeln!(self.header_output, "#pragma pack(push, 1)\n").unwrap();
    }

    fn write_header_footer(&mut self) {
        writeln!(self.header_output, "\n#pragma pack(pop)").unwrap();
        writeln!(
            self.header_output,
            "#endif // ONYX_{}_H_",
            self.file_stem.to_ascii_uppercase()
        )
        .unwrap();
    }

    fn write_source_includes(&mut self) {
        writeln!(
            self.source_output,
            "// Automatically generated by Onyx IDL compiler"
        )
        .unwrap();
        writeln!(self.source_output, "#include \"{}.hpp\"\n", self.file_stem).unwrap();
        writeln!(self.source_output, "#include <cstring> // For memcpy\n").unwrap();
    }

    fn write_enum(&mut self, e: &EnumDef) -> Result<(), CompileError> {
        let underlying_type = self.map_primitive_type_to_cpp(&e.underlying_type);
        writeln!(
            self.header_output,
            "enum class {} : {} {{",
            e.name, underlying_type
        )
        .unwrap();

        let mut current_value: u64 = 0;
        for variant in &e.variants {
            let assigned_value = if let Some(val) = variant.value {
                current_value = val;
                format!(" = {val}")
            } else {
                let s = if current_value == 0 {
                    String::new()
                } else {
                    format!(" = {current_value}")
                };
                current_value += 1;
                s
            };
            writeln!(self.header_output, "  {}{},", variant.name, assigned_value).unwrap();
        }
        writeln!(self.header_output, "}};").unwrap();
        Ok(())
    }

    fn write_struct(&mut self, s: &StructDef) -> Result<(), CompileError> {
        writeln!(self.header_output, "struct {} {{", s.name).unwrap();
        for field in &s.fields {
            let type_str = match &field.type_info {
                Type::Primitive(p) => self.map_primitive_type_to_cpp(p).to_string(),
                Type::Custom(s) => s.clone(),
            };

            let bit_field_suffix = if let Some(bits) = field.bit_field_size {
                if bits > 0 {
                    format!(" : {bits}")
                } else {
                    String::new()
                }
            } else {
                String::new()
            };

            writeln!(
                self.header_output,
                "  {type_str} {name}{bit_field_suffix};",
                name = field.name,
            )
            .unwrap();
        }
        writeln!(self.header_output, "}};").unwrap();
        Ok(())
    }

    fn write_message_declaration(
        &mut self,
        m: &MessageDef,
        packed_sizes: &HashMap<String, usize>,
    ) -> Result<(), CompileError> {
        let msg_size = *packed_sizes.get(&m.name).ok_or_else(|| {
            CompileError(format!(
                "Internal Error: Size not found for message {}",
                m.name
            ))
        })?;

        writeln!(self.header_output, "class {} {{", m.name).unwrap();
        writeln!(self.header_output, "public:").unwrap();
        writeln!(self.header_output, "  const size_t kSizeOf = {msg_size};").unwrap();
        writeln!(
            self.header_output,
            "  using Buffer = uint8_t[{msg_size}];\n"
        )
        .unwrap();

        // Declare members (fields)
        for field in &m.fields {
            let type_str = match &field.type_info {
                Type::Primitive(p) => self.map_primitive_type_to_cpp(p).to_string(),
                Type::Custom(s) => s.clone(),
            };

            let bit_field_suffix = if let Some(bits) = field.bit_field_size {
                if bits > 0 {
                    format!(" : {bits}")
                } else {
                    String::new()
                }
            } else {
                String::new()
            };

            writeln!(
                self.header_output,
                "  {type_str} {name}{bit_field_suffix};",
                name = field.name,
            )
            .unwrap();
        }

        // Declare the static deserialization method
        writeln!(self.header_output).unwrap();
        writeln!(
            self.header_output,
            "  /// Attempts to deserialize {} from a raw buffer.",
            m.name
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  /// Assumes a packed memory layout (no alignment padding)."
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  static {} Deserialize(const Buffer& buffer);",
            m.name
        )
        .unwrap();

        writeln!(self.header_output, "}};").unwrap();
        Ok(())
    }

    fn write_message_definition(
        &mut self,
        m: &MessageDef,
        namespace: &str,
    ) -> Result<(), CompileError> {
        let class_name = &m.name;

        // Implementation of the Deserialize method
        writeln!(self.source_output, "{namespace}::{class_name} {namespace}::{class_name}::Deserialize(const Buffer& buffer, size_t size) {{").unwrap();
        writeln!(
            self.source_output,
            "  {class_name}& packed = reinterpret_cast<{class_name}&>(buffer);"
        )
        .unwrap();
        writeln!(self.source_output, "  return {class_name} {{").unwrap();

        // Iterate and deserialize field by field to handle both endianness and bit-fields
        for field in &m.fields {
            // Only apply byteswap if it's NOT a bit-field and is a primitive type (custom types handle their own field deserialization)
            if field.bit_field_size.is_none() {
                match &field.type_info {
                    Type::Primitive(p) if p.get_byte_size() > 8 => writeln!(
                        self.source_output,
                        "    util::byteswap_if_needed(packed.{name}),",
                        name = field.name
                    )
                    .unwrap(),
                    Type::Primitive(_) => {
                        writeln!(self.source_output, "    packed.{name},", name = field.name)
                            .unwrap()
                    }
                    Type::Custom(s) => writeln!(
                        self.source_output,
                        "    {s}::Deserialize(reinterpret_cast<{s}&>(packed.{s})),"
                    )
                    .unwrap(),
                }
            } else {
                writeln!(self.source_output, "    packed.{name},", name = field.name).unwrap()
            }
        }

        writeln!(self.source_output, "  }};").unwrap();
        writeln!(self.source_output, "}}\n").unwrap();

        Ok(())
    }

    /// Writes the C++ utility functions for endianness handling.
    fn write_endianness_utilities(&mut self) {
        writeln!(self.header_output, "namespace utils {{\n").unwrap();

        // 1. Network Endianness Definition (Assumed Big Endian)
        writeln!(
            self.header_output,
            "// Define network endianness (usually Big Endian)."
        )
        .unwrap();
        writeln!(self.header_output, "#define ONYX_BIG_ENDIAN 4321").unwrap();
        writeln!(self.header_output, "#define ONYX_LITTLE_ENDIAN 1234").unwrap();
        writeln!(self.header_output, "// Default network order: Big Endian").unwrap();
        writeln!(
            self.header_output,
            "#define ONYX_NETWORK_ORDER ONYX_BIG_ENDIAN\n"
        )
        .unwrap();

        // 2. Host Endianness Check
        writeln!(
            self.header_output,
            "// Determine host endianness at compile time (using standard GCC/Clang macros)"
        )
        .unwrap();
        writeln!(self.header_output, "#ifdef __BYTE_ORDER__").unwrap();
        writeln!(
            self.header_output,
            "  #if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "    #define ONYX_HOST_ORDER ONYX_BIG_ENDIAN"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  #elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "    #define ONYX_HOST_ORDER ONYX_LITTLE_ENDIAN"
        )
        .unwrap();
        writeln!(self.header_output, "  #else").unwrap();
        writeln!(
            self.header_output,
            "    #error \"Unsupported host endianness\""
        )
        .unwrap();
        writeln!(self.header_output, "  #endif").unwrap();
        writeln!(
            self.header_output,
            "#elif defined(_WIN32) || defined(__LITTLE_ENDIAN__)"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  // Fallback for Windows (always little-endian) or other platforms"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  #define ONYX_HOST_ORDER ONYX_LITTLE_ENDIAN"
        )
        .unwrap();
        writeln!(self.header_output, "#else").unwrap();
        writeln!(
            self.header_output,
            "  #error \"Could not determine host endianness\""
        )
        .unwrap();
        writeln!(self.header_output, "#endif\n").unwrap();

        // --- 3. Byte Swap Functions (Explicit Overloads) ---
        let swap_types = vec![
            ("uint16_t", "2", false),
            ("int16_t", "2", false),
            ("uint32_t", "4", false),
            ("int32_t", "4", false),
            ("float", "4", true),
            ("uint64_t", "8", false),
            ("int64_t", "8", false),
            ("double", "8", true),
        ];

        writeln!(
            self.header_output,
            "// Helper function to swap bytes (Explicit Overloads)"
        )
        .unwrap();

        for (cpp_type, size, is_float) in &swap_types {
            if *is_float {
                // Special handling for floating point types
                let integer_type = if *size == "4" { "uint32_t" } else { "uint64_t" };
                writeln!(
                    self.header_output,
                    "inline {cpp_type} byteswap({cpp_type} value) {{"
                )
                .unwrap();
                writeln!(self.header_output, "  {integer_type} temp;").unwrap();
                writeln!(
                    self.header_output,
                    "  memcpy(&temp, &value, sizeof(value));"
                )
                .unwrap();
                writeln!(
                    self.header_output,
                    "  uint8_t* p = reinterpret_cast<uint8_t*>(&temp);"
                )
                .unwrap();
                writeln!(self.header_output, "  reverse(p, p + sizeof(temp));").unwrap();
                writeln!(
                    self.header_output,
                    "  memcpy(&value, &temp, sizeof(value));"
                )
                .unwrap();
                writeln!(self.header_output, "  return value;").unwrap();
                writeln!(self.header_output, "}}\n").unwrap();
            } else {
                // Handling for integer types
                writeln!(
                    self.header_output,
                    "inline {cpp_type} byteswap({cpp_type} value) {{"
                )
                .unwrap();
                writeln!(
                    self.header_output,
                    "  uint8_t* p = reinterpret_cast<std::uint8_t*>(&value);"
                )
                .unwrap();
                writeln!(self.header_output, "  reverse(p, p + sizeof(value));").unwrap();
                writeln!(self.header_output, "  return value;").unwrap();
                writeln!(self.header_output, "}}\n").unwrap();
            }
        }

        // --- 4. Conditional Byte Swap Utility (Explicit Overloads) ---
        writeln!(self.header_output, "\n// Swaps bytes if the host order does not match the network order (Explicit Overloads)").unwrap();

        // Generate byteswap_if_needed for all multi-byte types
        for (cpp_type, _, _) in swap_types {
            writeln!(
                self.header_output,
                "inline {cpp_type} byteswap_if_needed({cpp_type} value) {{"
            )
            .unwrap();
            writeln!(
                self.header_output,
                "  if (ONX_HOST_ORDER != ONX_NETWORK_ORDER) {{"
            )
            .unwrap();
            writeln!(self.header_output, "    return byteswap(value);").unwrap();
            writeln!(self.header_output, "  }}").unwrap();
            writeln!(self.header_output, "  return value;").unwrap();
            writeln!(self.header_output, "}}\n").unwrap();
        }

        writeln!(self.header_output, "}} // namespace utils\n").unwrap();
    }
}

impl CodeGenerator for CppGenerator {
    fn generate(
        &mut self,
        module: &OnyxModule,
        packed_sizes: &HashMap<String, usize>,
    ) -> Result<Vec<(String, String)>, CompileError> {
        self.header_output.clear();
        self.source_output.clear();

        let namespace = "onyx";

        self.write_header_includes();

        writeln!(self.header_output, "namespace {namespace} {{").unwrap();
        writeln!(self.source_output, "namespace {namespace} {{\n").unwrap();

        self.write_endianness_utilities();

        self.write_source_includes();

        for def in &module.definitions {
            match def {
                Definition::Enum(e) => {
                    // Enums go entirely in the header
                    self.write_enum(e)?;
                    writeln!(self.header_output).unwrap();
                }
                Definition::Struct(s) => {
                    // Structs go entirely in the header
                    self.write_struct(s)?;
                    writeln!(self.header_output).unwrap();
                }
                Definition::Message(m) => {
                    // Messages require both header (declaration) and source (definition)
                    self.write_message_declaration(m, packed_sizes)?;
                    writeln!(self.header_output).unwrap();
                    self.write_message_definition(m, namespace)?;
                }
            }
        }

        writeln!(self.header_output, "}} // namespace {namespace}").unwrap();
        writeln!(self.source_output, "}} // namespace {namespace}").unwrap();

        self.write_header_footer();

        Ok(vec![
            (
                format!("{}.hpp", self.file_stem).to_string(),
                self.header_output.clone(),
            ),
            (
                format!("{}.cpp", self.file_stem).to_string(),
                self.source_output.clone(),
            ),
        ])
    }
}
