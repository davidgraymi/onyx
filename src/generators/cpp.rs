use std::fmt::Write;

use crate::{
    ast::{
        Definition, EnumDef, MessageDef, OnyxModule, PrimitiveType, StructDef, Type, WireEndianness,
    },
    generators::{CodeGenerator, CompileError},
};

pub struct CppGenerator {
    header_output: String,
    source_output: String,
    pub file_stem: String,
}

impl Default for CppGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl CppGenerator {
    const BIG_ENDIAN_DEFINE: &str = "ONYX_BIG_ENDIAN";
    const LITTLE_ENDIAN_DEFINE: &str = "ONYX_LITTLE_ENDIAN";
    const NETWORK_ENDIAN_DEFINE: &str = "ONYX_NETWORK_ORDER";
    const HOST_ENDIAN_DEFINE: &str = "ONYX_HOST_ORDER";

    pub fn new() -> Self {
        CppGenerator {
            header_output: String::new(),
            source_output: String::new(),
            file_stem: String::new(),
        }
    }

    /// Maps Onyx PrimitiveType to C++ type strings.
    fn map_primitive_type_to_cpp(&self, p: &PrimitiveType) -> &'static str {
        match p {
            PrimitiveType::Bool => "bool",
            PrimitiveType::U8 => "uint8_t",
            PrimitiveType::U16 => "uint16_t",
            PrimitiveType::U32 => "uint32_t",
            PrimitiveType::U64 => "uint64_t",
            PrimitiveType::I8 => "int8_t",
            PrimitiveType::I16 => "int16_t",
            PrimitiveType::I32 => "int32_t",
            PrimitiveType::I64 => "int64_t",
            PrimitiveType::F32 => "float",
            PrimitiveType::F64 => "double",
        }
    }

    fn map_endianness_to_define(&self, endianness: &WireEndianness) -> &'static str {
        match endianness {
            WireEndianness::Big => Self::BIG_ENDIAN_DEFINE,
            WireEndianness::Little => Self::LITTLE_ENDIAN_DEFINE,
        }
    }

    fn write_header_includes(&mut self) {
        writeln!(
            self.header_output,
            "// Automatically generated by Onyx IDL compiler"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#ifndef ONYX_{}_H_",
            self.file_stem.to_ascii_uppercase()
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#define ONYX_{}_H_\n",
            self.file_stem.to_ascii_uppercase()
        )
        .unwrap();
        writeln!(self.header_output, "#include <stdint.h>").unwrap();
        writeln!(self.header_output, "#include <string.h>\n").unwrap();
        writeln!(self.header_output, "#pragma pack(push, 1)\n").unwrap();
    }

    fn write_header_footer(&mut self) {
        writeln!(self.header_output, "\n#pragma pack(pop)").unwrap();
        writeln!(
            self.header_output,
            "#endif // ONYX_{}_H_",
            self.file_stem.to_ascii_uppercase()
        )
        .unwrap();
    }

    fn write_source_includes(&mut self) {
        writeln!(
            self.source_output,
            "// Automatically generated by Onyx IDL compiler"
        )
        .unwrap();
        writeln!(self.source_output, "#include \"{}.hpp\"\n", self.file_stem).unwrap();
        writeln!(self.source_output, "#include <string.h>\n").unwrap();
    }

    fn write_enum(&mut self, e: &EnumDef) -> Result<(), CompileError> {
        let underlying_type = self.map_primitive_type_to_cpp(&e.underlying_type);
        writeln!(
            self.header_output,
            "enum class {} : {} {{",
            e.name, underlying_type
        )
        .unwrap();

        let mut current_value: u64 = 0;
        for variant in &e.variants {
            let assigned_value = if let Some(val) = variant.value {
                current_value = val;
                format!(" = {val}")
            } else {
                let s = if current_value == 0 {
                    String::new()
                } else {
                    format!(" = {current_value}")
                };
                current_value += 1;
                s
            };
            writeln!(self.header_output, "  {}{},", variant.name, assigned_value).unwrap();
        }
        writeln!(self.header_output, "}};").unwrap();
        Ok(())
    }

    fn write_struct(&mut self, s: &StructDef) -> Result<(), CompileError> {
        writeln!(self.header_output, "struct {} {{", s.name).unwrap();
        for field in &s.fields {
            let type_str = match &field.type_info {
                Type::Primitive(p) => self.map_primitive_type_to_cpp(p).to_string(),
                Type::Custom(s) => s.clone(),
            };

            let bit_field_suffix = if let Some(bits) = field.bit_field_size {
                if bits > 0 {
                    format!(" : {bits}")
                } else {
                    String::new()
                }
            } else {
                String::new()
            };

            writeln!(
                self.header_output,
                "  {type_str} {name}{bit_field_suffix};",
                name = field.name,
            )
            .unwrap();
        }
        writeln!(self.header_output, "}};").unwrap();
        Ok(())
    }

    fn write_message_declaration(&mut self, m: &MessageDef) -> Result<(), CompileError> {
        let msg_size = m.size.ok_or_else(|| {
            CompileError(format!(
                "Internal Error: Size not found for message {}",
                m.name
            ))
        })?;

        writeln!(self.header_output, "class {} {{", m.name).unwrap();
        writeln!(self.header_output, "public:").unwrap();
        writeln!(self.header_output, "  const size_t kSizeOf = {msg_size};").unwrap();
        writeln!(
            self.header_output,
            "  using Buffer = uint8_t[{msg_size}];\n"
        )
        .unwrap();

        // Declare members (fields)
        for field in &m.fields {
            let type_str = match &field.type_info {
                Type::Primitive(p) => self.map_primitive_type_to_cpp(p).to_string(),
                Type::Custom(s) => s.clone(),
            };

            let bit_field_suffix = if let Some(bits) = field.bit_field_size {
                if bits > 0 {
                    format!(" : {bits}")
                } else {
                    String::new()
                }
            } else {
                String::new()
            };

            writeln!(
                self.header_output,
                "  {type_str} {name}{bit_field_suffix};",
                name = field.name,
            )
            .unwrap();
        }

        // Declare the static deserialization method
        writeln!(self.header_output).unwrap();
        writeln!(
            self.header_output,
            "  /// Attempts to deserialize {} from a raw buffer.",
            m.name
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  /// Assumes a packed memory layout (no alignment padding)."
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  static {} Deserialize(const Buffer& buffer);",
            m.name
        )
        .unwrap();

        writeln!(self.header_output, "}};").unwrap();
        Ok(())
    }

    fn write_message_definition(&mut self, m: &MessageDef) -> Result<(), CompileError> {
        let class_name = &m.name;

        // Implementation of the Deserialize method
        writeln!(
            self.source_output,
            "{class_name} {class_name}::Deserialize(const Buffer& buffer, size_t size) {{"
        )
        .unwrap();
        writeln!(
            self.source_output,
            "  {class_name}& packed = reinterpret_cast<{class_name}&>(buffer);"
        )
        .unwrap();
        writeln!(self.source_output, "  return {class_name} {{").unwrap();

        // Iterate and deserialize field by field to handle both endianness and bit-fields
        for field in &m.fields {
            // Only apply byteswap if it's NOT a bit-field and is a primitive type (custom types handle their own field deserialization)
            if field.bit_field_size.is_none() {
                match &field.type_info {
                    Type::Primitive(p) if p.get_byte_size() > 8 => writeln!(
                        self.source_output,
                        "    util::byteswap_if_needed(packed.{name}),",
                        name = field.name
                    )
                    .unwrap(),
                    Type::Primitive(_) => {
                        writeln!(self.source_output, "    packed.{name},", name = field.name)
                            .unwrap()
                    }
                    Type::Custom(s) => writeln!(
                        self.source_output,
                        "    {s}::Deserialize(reinterpret_cast<{s}&>(packed.{s})),"
                    )
                    .unwrap(),
                }
            } else {
                writeln!(self.source_output, "    packed.{name},", name = field.name).unwrap()
            }
        }

        writeln!(self.source_output, "  }};").unwrap();
        writeln!(self.source_output, "}}\n").unwrap();

        Ok(())
    }

    /// Writes the C++ utility functions for endianness handling.
    fn write_endianness_utilities(&mut self, endianness: &WireEndianness) {
        writeln!(self.header_output, "namespace utils {{\n").unwrap();

        // 1. Network Endianness Definition (Assumed Big Endian)
        writeln!(
            self.header_output,
            "// Define network endianness (usually Big Endian)."
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#define {} 4321",
            Self::BIG_ENDIAN_DEFINE
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#define {} 1234",
            Self::LITTLE_ENDIAN_DEFINE
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#define {} {}\n",
            Self::NETWORK_ENDIAN_DEFINE,
            self.map_endianness_to_define(endianness)
        )
        .unwrap();

        // 2. Host Endianness Check
        writeln!(
            self.header_output,
            "// Determine host endianness at compile time (using standard GCC/Clang macros)"
        )
        .unwrap();
        writeln!(self.header_output, "#ifdef __BYTE_ORDER__").unwrap();
        writeln!(
            self.header_output,
            "  #if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "    #define {} {}",
            Self::HOST_ENDIAN_DEFINE,
            Self::BIG_ENDIAN_DEFINE
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  #elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "    #define {} {}",
            Self::HOST_ENDIAN_DEFINE,
            Self::LITTLE_ENDIAN_DEFINE
        )
        .unwrap();
        writeln!(self.header_output, "  #else").unwrap();
        writeln!(
            self.header_output,
            "    #error \"Unsupported host endianness\""
        )
        .unwrap();
        writeln!(self.header_output, "  #endif").unwrap();
        writeln!(
            self.header_output,
            "#elif defined(_WIN32) || defined(__LITTLE_ENDIAN__)"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  // Fallback for Windows (always little-endian) or other platforms"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  #define {} {}",
            Self::HOST_ENDIAN_DEFINE,
            Self::LITTLE_ENDIAN_DEFINE
        )
        .unwrap();
        writeln!(self.header_output, "#else").unwrap();
        writeln!(
            self.header_output,
            "  #error \"Could not determine host endianness\""
        )
        .unwrap();
        writeln!(self.header_output, "#endif\n").unwrap();

        // --- 3. Byte Swap Functions (Explicit Overloads) ---
        let swap_types = vec![
            (
                "uint16_t",
                "int16_t",
                "((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF)",
            ),
            (
                "uint32_t",
                "int32_t",
                "(value << 24) | ((value & 0x00FF0000) >> 8) | ((value & 0x0000FF00) << 8) | (value >> 24)",
            ),
            (
                "uint64_t",
                "int64_t",
                "(value << 56) | ((value & 0x00FF000000000000ULL) >> 40) | ((value & 0x0000FF0000000000ULL) >> 24) | ((value & 0x000000FF00000000ULL) >> 8) | ((value & 0x00000000FF000000ULL) << 8) | ((value & 0x0000000000FF0000ULL) << 24) | ((value & 0x000000000000FF00ULL) << 40) | (value >> 56)",
            ),
        ];

        writeln!(
            self.header_output,
            "// Helper function to swap bytes (Explicit Overloads)"
        )
        .unwrap();

        for (u_type, i_type, logic) in &swap_types {
            // Unsigned Integers
            writeln!(
                self.header_output,
                "inline {u_type} byteswap({u_type} value) {{ return {logic}; }}\n"
            )
            .unwrap();

            // Signed Integers
            let i_logic = format!("({i_type})byteswap(({u_type})value)");
            writeln!(
                self.header_output,
                "inline {i_type} byteswap({i_type} value) {{ return {i_logic}; }}\n"
            )
            .unwrap();
        }

        let float_types = vec![("float", "uint32_t"), ("double", "uint64_t")];

        for (f_type, i_type) in float_types {
            writeln!(
                self.header_output,
                "inline {f_type} byteswap({f_type} value) {{"
            )
            .unwrap();
            writeln!(self.header_output, "  {i_type} temp;").unwrap();
            writeln!(
                self.header_output,
                "  memcpy(&temp, &value, sizeof(value));"
            )
            .unwrap();
            writeln!(self.header_output, "  temp = byteswap(temp);").unwrap();
            writeln!(
                self.header_output,
                "  memcpy(&value, &temp, sizeof(value));"
            )
            .unwrap();
            writeln!(self.header_output, "  return value;").unwrap();
            writeln!(self.header_output, "}}\n").unwrap();
        }

        // --- 4. Conditional Byte Swap Utility (Explicit Overloads) ---
        writeln!(
            self.header_output,
            "// Swaps bytes if the host order does not match the network order (Explicit Overloads)"
        )
        .unwrap();

        // Generate byteswap_if_needed for all multi-byte types
        for (cpp_type, _, _) in swap_types {
            writeln!(
                self.header_output,
                "inline {cpp_type} byteswap_if_needed({cpp_type} value) {{"
            )
            .unwrap();
            writeln!(
                self.header_output,
                "  if ({} != {}) {{",
                Self::HOST_ENDIAN_DEFINE,
                Self::NETWORK_ENDIAN_DEFINE
            )
            .unwrap();
            writeln!(self.header_output, "    return byteswap(value);").unwrap();
            writeln!(self.header_output, "  }}").unwrap();
            writeln!(self.header_output, "  return value;").unwrap();
            writeln!(self.header_output, "}}\n").unwrap();
        }

        writeln!(self.header_output, "}} // namespace utils").unwrap();
    }
}

impl CodeGenerator for CppGenerator {
    fn generate(&mut self, module: &OnyxModule) -> Result<Vec<(String, String)>, CompileError> {
        self.header_output.clear();
        self.source_output.clear();

        let namespace = "onyx";

        self.write_header_includes();
        self.write_source_includes();

        writeln!(self.header_output, "namespace {namespace} {{").unwrap();
        writeln!(self.source_output, "namespace {namespace} {{\n").unwrap();

        self.write_endianness_utilities(&module.endianness);
        writeln!(self.header_output).unwrap();

        for def in module.definitions.values() {
            match def {
                Definition::Enum(e) => {
                    // Enums go entirely in the header
                    self.write_enum(e)?;
                    writeln!(self.header_output).unwrap();
                }
                Definition::Struct(s) => {
                    // Structs go entirely in the header
                    self.write_struct(s)?;
                    writeln!(self.header_output).unwrap();
                }
                Definition::Message(m) => {
                    // Messages require both header (declaration) and source (definition)
                    self.write_message_declaration(m)?;
                    writeln!(self.header_output).unwrap();
                    self.write_message_definition(m)?;
                }
            }
        }

        writeln!(self.header_output, "}} // namespace {namespace}").unwrap();
        writeln!(self.source_output, "}} // namespace {namespace}").unwrap();

        self.write_header_footer();

        Ok(vec![
            (
                format!("{}.hpp", self.file_stem).to_string(),
                self.header_output.clone(),
            ),
            (
                format!("{}.cpp", self.file_stem).to_string(),
                self.source_output.clone(),
            ),
        ])
    }
}
