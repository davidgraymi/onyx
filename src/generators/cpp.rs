use std::{
    fmt::Write,
    path::{MAIN_SEPARATOR, PathBuf},
};

use crate::{
    ast::{Definition, EnumDef, Field, OnyxModule, PrimitiveType, Type, WireEndianness},
    generators::{CodeGenerator, CompileError},
};

/// Configuration settings specific to Python code generation
#[derive(Debug, Clone)]
pub struct CppConfig {
    /// Number of spaces to use for each indentation level.
    pub indent_spaces: usize,
}

impl Default for CppConfig {
    fn default() -> Self {
        CppConfig { indent_spaces: 4 }
    }
}

impl CppConfig {
    pub fn get_indent(&self, num: usize) -> String {
        " ".repeat(self.indent_spaces * num)
    }
}

#[derive(Debug, Default)]
pub struct CppGenerator {
    config: CppConfig,
    header_output: String,
    source_output: String,
    file_path: PathBuf,
    file_stem: String,
}

impl CppGenerator {
    const BIG_ENDIAN_DEFINE: &str = "ONYX_BIG_ENDIAN";
    const LITTLE_ENDIAN_DEFINE: &str = "ONYX_LITTLE_ENDIAN";
    const NETWORK_ENDIAN_DEFINE: &str = "ONYX_NETWORK_ORDER";
    const HOST_ENDIAN_DEFINE: &str = "ONYX_HOST_ORDER";

    pub fn add_file_path(&mut self, file_path: PathBuf) -> Result<(), CompileError> {
        self.file_path = file_path;
        self.file_stem = match self.file_path.file_stem() {
            Some(s) => s.to_string_lossy().to_string(),
            None => return Err(CompileError(String::new())),
        };
        Ok(())
    }

    fn file_stem_define(&self) -> String {
        self.file_path
            .to_string_lossy()
            .to_ascii_uppercase()
            .replace(MAIN_SEPARATOR, "_")
            .replace("/", "_")
            .replace("\\", "_")
            .replace("-", "_")
    }

    /// Maps Onyx PrimitiveType to C++ type strings.
    fn map_primitive_type_to_cpp(&self, p: &PrimitiveType) -> &'static str {
        match p {
            PrimitiveType::Bool => "bool",
            PrimitiveType::U8 => "uint8_t",
            PrimitiveType::U16 => "uint16_t",
            PrimitiveType::U32 => "uint32_t",
            PrimitiveType::U64 => "uint64_t",
            PrimitiveType::I8 => "int8_t",
            PrimitiveType::I16 => "int16_t",
            PrimitiveType::I32 => "int32_t",
            PrimitiveType::I64 => "int64_t",
            PrimitiveType::F32 => "float",
            PrimitiveType::F64 => "double",
        }
    }

    fn map_byte_width_to_cpp(&self, size: &usize) -> &'static str {
        assert!(*size > 0);
        assert!(*size < 9);
        if *size == 1 {
            return "uint8_t";
        } else if *size >= 2 && *size < 4 {
            return "uint16_t";
        } else if *size >= 4 && *size < 8 {
            return "uint32_t";
        } else if *size == 8 {
            return "uint64_t";
        }
        panic!("unexpected size");
    }

    fn map_endianness_to_define(&self, endianness: &WireEndianness) -> &'static str {
        match endianness {
            WireEndianness::Big => Self::BIG_ENDIAN_DEFINE,
            WireEndianness::Little => Self::LITTLE_ENDIAN_DEFINE,
        }
    }

    fn get_primitive_cpp_type(&self, type_info: &Type) -> String {
        match type_info {
            Type::Primitive(p) => self.map_primitive_type_to_cpp(p).to_string(),
            Type::Custom(s) => s.clone(),
        }
    }

    fn get_field_groups<'a>(&self, fields: &'a Vec<Field>) -> Vec<Vec<&'a Field>> {
        let mut field_groups: Vec<Vec<&Field>> = Vec::new();
        let mut current_group: Vec<&Field> = Vec::new();

        for field in fields {
            if field.bit_field_size.is_some() {
                // Group consecutive bit-fields
                current_group.push(field);
            } else {
                // Non-bit-field encountered. Process the current group, then the standalone field.
                if !current_group.is_empty() {
                    field_groups.push(std::mem::take(&mut current_group));
                }
                field_groups.push(vec![field]); // Non-bit-field is a group of size 1
            }
        }
        if !current_group.is_empty() {
            field_groups.push(current_group);
        }
        field_groups
    }

    fn write_header_includes(&mut self) {
        writeln!(
            self.header_output,
            "// Automatically generated by Onyx IDL compiler"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#ifndef ONYX_{}_H_",
            self.file_stem_define()
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#define ONYX_{}_H_\n",
            self.file_stem_define()
        )
        .unwrap();
        writeln!(self.header_output, "#include <stdint.h>").unwrap();
        writeln!(self.header_output, "#include <string.h>\n").unwrap();
        writeln!(self.header_output, "#pragma pack(push, 1)\n").unwrap();
    }

    fn write_header_footer(&mut self) {
        writeln!(self.header_output, "\n#pragma pack(pop)").unwrap();
        writeln!(
            self.header_output,
            "#endif // ONYX_{}_H_",
            self.file_stem_define()
        )
        .unwrap();
    }

    fn write_source_includes(&mut self) {
        writeln!(
            self.source_output,
            "// Automatically generated by Onyx IDL compiler"
        )
        .unwrap();
        writeln!(self.source_output, "#include \"{}.hpp\"\n", self.file_stem).unwrap();
        writeln!(self.source_output, "#include <string.h>\n").unwrap();
    }

    fn write_enum(&mut self, e: &EnumDef) -> Result<(), CompileError> {
        let underlying_type = self.map_primitive_type_to_cpp(&e.underlying_type);
        writeln!(
            self.header_output,
            "enum class {} : {} {{",
            e.name, underlying_type
        )
        .unwrap();

        let mut current_value: u64 = 0;
        for variant in &e.variants {
            let assigned_value = if let Some(val) = variant.value {
                current_value = val;
                format!(" = {val}")
            } else {
                let s = if current_value == 0 {
                    String::new()
                } else {
                    format!(" = {current_value}")
                };
                current_value += 1;
                s
            };
            writeln!(
                self.header_output,
                "{}{}{},",
                self.config.get_indent(1),
                variant.name,
                assigned_value
            )
            .unwrap();
        }
        writeln!(self.header_output, "}};").unwrap();
        Ok(())
    }

    fn write_class_declaration(
        &mut self,
        class_name: &String,
        field_groups: &Vec<Vec<&Field>>,
        module: &OnyxModule,
        size: usize,
    ) {
        writeln!(self.header_output, "class {class_name} {{").unwrap();
        writeln!(self.header_output, "private:").unwrap();

        // Declare members (fields)
        for group in field_groups {
            let first_field = group[0];
            let mut container_bits = 0;
            for field in group {
                container_bits += field.get_bit_width(module);
            }
            let container_bytes = container_bits.div_ceil(8);

            if group.len() > 1 || first_field.bit_field_size.is_some() {
                // This is a bit-field group, replace with a raw container field (byte array)
                let container_name = format!("__raw_{}", first_field.name);
                writeln!(
                    self.header_output,
                    "{}uint8_t {container_name}[{container_bytes}];",
                    self.config.get_indent(1)
                )
                .unwrap();
            } else {
                // Non-bit-field, or a single primitive/custom type (use raw prefix for consistency)
                let type_str = self.get_primitive_cpp_type(&first_field.type_info);
                writeln!(
                    self.header_output,
                    "{}{type_str} __raw_{name};",
                    self.config.get_indent(1),
                    name = first_field.name,
                )
                .unwrap();
            }
        }

        // Public accessors
        writeln!(self.header_output, "\npublic:").unwrap();
        writeln!(
            self.header_output,
            "{}static const size_t kSizeOf = {size};",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}using Buffer = uint8_t[kSizeOf];\n",
            self.config.get_indent(1)
        )
        .unwrap();

        // Generate Public Accessors for Bit-Field Groups
        for group in field_groups {
            let first_field = group[0];
            if group.len() > 1 || first_field.bit_field_size.is_some() {
                // It's a bit-field group, generate portable accessors
                let container_name = format!("__raw_{}", first_field.name);

                let mut current_bit_offset: usize = 0;

                for field in group {
                    let field_type_str = self.get_primitive_cpp_type(&field.type_info);
                    let bits = field.bit_field_size.unwrap_or(0);
                    let mask = (1u64 << bits).saturating_sub(1);
                    let current_byte_offset = current_bit_offset / 8;
                    let local_bit_offset = current_bit_offset % 8;
                    let temp_bit_width = local_bit_offset + bits;
                    let temp_byte_width = temp_bit_width.div_ceil(8);
                    let temp_container = self.map_byte_width_to_cpp(&temp_byte_width);

                    // Accessor logic
                    writeln!(
                        self.header_output,
                        "{}/// Accessor for {field_name}",
                        self.config.get_indent(1),
                        field_name = field.name
                    )
                    .unwrap();
                    writeln!(
                        self.header_output,
                        "{}inline const {field_type_str} {field_name}() const {{",
                        self.config.get_indent(1),
                        field_name = field.name,
                    )
                    .unwrap();
                    writeln!(
                        self.header_output,
                        "{}auto raw_value = reinterpret_cast<const {temp_container}*>(&{container_name}[{current_byte_offset}]);", self.config.get_indent(2)
                    ).unwrap();
                    writeln!(
                        self.header_output,
                        "{}return static_cast<const {field_type_str}>(((*raw_value >> {current_bit_offset}) & 0x{mask:X}));", self.config.get_indent(2)
                    )
                    .unwrap();
                    writeln!(self.header_output, "{}}}\n", self.config.get_indent(1)).unwrap();

                    // Mutator logic
                    writeln!(
                        self.header_output,
                        "{}/// Mutator for {field_name}",
                        self.config.get_indent(1),
                        field_name = field.name
                    )
                    .unwrap();
                    writeln!(
                        self.header_output,
                        "{}inline void {field_name}({field_type_str} value) {{",
                        self.config.get_indent(1),
                        field_name = field.name
                    )
                    .unwrap();
                    writeln!(self.header_output, "{}auto raw_container = reinterpret_cast<{temp_container}*>(&{container_name}[{current_byte_offset}]);", self.config.get_indent(2)).unwrap();
                    writeln!(self.header_output,"{}*raw_container &= ~((({temp_container})0x{mask:X}) << {current_bit_offset});", self.config.get_indent(2)).unwrap();
                    writeln!(self.header_output,"{}*raw_container |= (((({temp_container})value) & 0x{mask:X}) << {current_bit_offset});", self.config.get_indent(2)).unwrap();
                    writeln!(self.header_output, "{}}}\n", self.config.get_indent(1)).unwrap();

                    current_bit_offset += bits;
                }
            } else {
                // Non-Bit-Field
                let field = group[0];
                let type_str = self.get_primitive_cpp_type(&field.type_info);
                let is_class = match &field.type_info {
                    Type::Custom(s) => matches!(
                        module.definitions.get(s),
                        Some(Definition::Struct(_)) | Some(Definition::Message(_))
                    ),
                    _ => false,
                };
                let accessor_const = if is_class {
                    String::new()
                } else {
                    "const ".to_string()
                };
                let pass_by_ref = if is_class {
                    "&".to_string()
                } else {
                    String::new()
                };

                // Accessor
                writeln!(
                    self.header_output,
                    "{}/// Accessor for {name}",
                    self.config.get_indent(1),
                    name = field.name
                )
                .unwrap();
                writeln!(
                    self.header_output,
                    "{}inline {accessor_const}{type_str}{pass_by_ref} {name}() {accessor_const}{{ return __raw_{name}; }}\n",
                    self.config.get_indent(1),
                    name = field.name
                )
                .unwrap();

                // Mutator
                writeln!(
                    self.header_output,
                    "{}/// Mutator for {name}",
                    self.config.get_indent(1),
                    name = field.name
                )
                .unwrap();
                writeln!(
                    self.header_output,
                    "{}inline void {name}(const {type_str} value) {{ __raw_{name} = value; }}\n",
                    self.config.get_indent(1),
                    name = field.name
                )
                .unwrap();
            }
        }

        // Declare the static deserialization method
        writeln!(
            self.header_output,
            "{}/// Deserializes the network-endian buffer to {class_name} in-place by casting",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}/// and applying endianness correction to match the host-endianness.",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}/// NOTE: This mutates the input buffer to host-endianness.",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}/// Returns a pointer to the object within the buffer.",
            self.config.get_indent(1),
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}static {class_name}* Deserialize(Buffer& buffer);",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(self.header_output).unwrap();

        // Decalre the serialization method
        writeln!(
            self.header_output,
            "{}/// Serializes the host-endian object into the provided buffer,",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}/// applying endianness correction to match the network-endianness.",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}void Serialize(Buffer& buffer) const;",
            self.config.get_indent(1)
        )
        .unwrap();

        writeln!(self.header_output, "}};").unwrap();
    }

    fn write_class_definition(
        &mut self,
        module: &OnyxModule,
        class_name: &String,
        field_groups: &Vec<Vec<&Field>>,
    ) {
        // Implementation of the Deserialize method
        writeln!(
            self.source_output,
            "{class_name}* {class_name}::Deserialize(Buffer& buffer) {{"
        )
        .unwrap();

        writeln!(
            self.source_output,
            "{}// Overlay the class structure onto the buffer memory. This is the zero-copy step.",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.source_output,
            "{}{class_name}* result = ({class_name}*)buffer;",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(self.source_output).unwrap();

        // Iterate and apply in-place swapping
        for group in field_groups {
            let first_field = group[0];
            let name = &first_field.name;

            if group.len() > 1 || first_field.bit_field_size.is_some() {
                // CASE 1: Bit-Field Container (uint8_t __raw_{name}[N])
                let bytes = first_field.get_bit_width(module).div_ceil(8);
                if bytes > 1 {
                    let container_type = match bytes {
                        2 => "uint16_t",
                        4 => "uint32_t",
                        8 => "uint64_t",
                        _ => "void",
                    };
                    writeln!(
                        self.source_output,
                        "{}// SWAP: Bit-field container {name}",
                        self.config.get_indent(1)
                    )
                    .unwrap();
                    writeln!(
                        self.source_output,
                        "{}*({container_type}*)result->__raw_{name} = utils::byteswap_if_needed(*({container_type}*)result->__raw_{name});",
                        self.config.get_indent(1)
                    ).unwrap();
                } else {
                    writeln!(
                        self.source_output,
                        "{}// INFO: Bit-field container {name} (1 byte), no swap needed.",
                        self.config.get_indent(1)
                    )
                    .unwrap();
                }
            } else {
                // CASE 2: Primitive or Custom Field (__raw_{name})
                match &first_field.type_info {
                    Type::Primitive(p) => {
                        if p.get_bit_width().div_ceil(8) > 1 {
                            // Primitive: In-place swap
                            writeln!(
                                self.source_output,
                                "{}// SWAP: Primitive field {name}",
                                self.config.get_indent(1)
                            )
                            .unwrap();
                            writeln!(
                                self.source_output,
                                "{}result->__raw_{name} = utils::byteswap_if_needed(result->__raw_{name});", self.config.get_indent(1)
                            ).unwrap();
                        } else {
                            writeln!(
                                self.source_output,
                                "{}// INFO: Primitive field {name} (1 byte), no swap needed.",
                                self.config.get_indent(1)
                            )
                            .unwrap();
                        }
                    }
                    Type::Custom(s) => {
                        match module.definitions.get(s).unwrap() {
                            Definition::Struct(_) | Definition::Message(_) => {
                                writeln!(
                                    self.source_output,
                                    "{}{s}::Deserialize(*({s}::Buffer*) &result->__raw_{name});",
                                    self.config.get_indent(1)
                                )
                                .unwrap();
                            }
                            Definition::Enum(_) => {}
                        }
                        // Call Deserialize on the memory block where the nested struct resides
                    }
                }
            }
        }

        writeln!(self.source_output).unwrap();
        writeln!(
            self.source_output,
            "{}return result;",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(self.source_output, "}}\n").unwrap();

        // Implementation of the Serialize method
        writeln!(
            self.source_output,
            "void {class_name}::Serialize(Buffer& buffer) const {{"
        )
        .unwrap();

        writeln!(
            self.source_output,
            "{}// Copy the host-endian object into the buffer first.",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.source_output,
            "{}memcpy(buffer, this, kSizeOf);",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.source_output,
            "{}{class_name}* wire_format_data = ({class_name}*)buffer;",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(self.source_output).unwrap();

        // Iterate and apply in-place swapping (wire -> host)
        for group in field_groups {
            let first_field = group[0];
            let name = &first_field.name;

            if group.len() > 1 || first_field.bit_field_size.is_some() {
                // CASE 1: Bit-Field Container (uint8_t __raw_{name}[N])
                let bytes = first_field.get_bit_width(module).div_ceil(8);
                if bytes > 1 {
                    let container_type = match bytes {
                        2 => "uint16_t",
                        4 => "uint32_t",
                        8 => "uint64_t",
                        _ => "void",
                    };
                    writeln!(
                        self.source_output,
                        "{}// SWAP: Bit-field container {name}",
                        self.config.get_indent(1)
                    )
                    .unwrap();
                    writeln!(
                        self.source_output,
                        "{}*({container_type}*)wire_format_data->__raw_{name} = utils::byteswap_if_needed(*({container_type}*)wire_format_data->__raw_{name});",
                        self.config.get_indent(1)
                    ).unwrap();
                } else {
                    writeln!(
                        self.source_output,
                        "{}// INFO: Bit-field container {name} (1 byte), no swap needed.",
                        self.config.get_indent(1)
                    )
                    .unwrap();
                }
            } else {
                // CASE 2: Primitive or Custom Field (__raw_{name})
                match &first_field.type_info {
                    Type::Primitive(p) => {
                        if p.get_bit_width().div_ceil(8) > 1 {
                            // Primitive: In-place swap
                            writeln!(
                                self.source_output,
                                "{}// SWAP: Primitive field {name}",
                                self.config.get_indent(1),
                            )
                            .unwrap();
                            writeln!(
                                self.source_output,
                                "{}wire_format_data->__raw_{name} = utils::byteswap_if_needed(wire_format_data->__raw_{name});", self.config.get_indent(1)
                            ).unwrap();
                        } else {
                            writeln!(
                                self.source_output,
                                "{}// INFO: Primitive field {name} (1 byte), no swap needed.",
                                self.config.get_indent(1)
                            )
                            .unwrap();
                        }
                    }
                    Type::Custom(s) => {
                        match module.definitions.get(s).unwrap() {
                            Definition::Struct(_) | Definition::Message(_) => {
                                writeln!(
                                    self.source_output,
                                    "{}wire_format_data->__raw_{name}.Serialize(*({s}::Buffer*) &wire_format_data->__raw_{name});", self.config.get_indent(1)
                                )
                                .unwrap();
                            }
                            Definition::Enum(_) => {}
                        }
                        // Call Deserialize on the memory block where the nested struct resides
                    }
                }
            }
        }

        writeln!(self.source_output, "}}\n").unwrap();
    }

    /// Writes the C++ utility functions for endianness handling.
    fn write_endianness_utilities(&mut self, endianness: &WireEndianness) {
        writeln!(self.header_output, "namespace utils {{\n").unwrap();

        // 1. Network Endianness Definition (Assumed Big Endian)
        writeln!(
            self.header_output,
            "// Define network endianness (usually Big Endian)."
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#define {} 4321",
            Self::BIG_ENDIAN_DEFINE
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#define {} 1234",
            Self::LITTLE_ENDIAN_DEFINE
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#define {} {}\n",
            Self::NETWORK_ENDIAN_DEFINE,
            self.map_endianness_to_define(endianness)
        )
        .unwrap();

        // 2. Host Endianness Check
        writeln!(
            self.header_output,
            "// Determine host endianness at compile time (using standard GCC/Clang macros)"
        )
        .unwrap();
        writeln!(self.header_output, "#ifdef __BYTE_ORDER__").unwrap();
        writeln!(
            self.header_output,
            "{}#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}#define {} {}",
            self.config.get_indent(2),
            Self::HOST_ENDIAN_DEFINE,
            Self::BIG_ENDIAN_DEFINE
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}#define {} {}",
            self.config.get_indent(2),
            Self::HOST_ENDIAN_DEFINE,
            Self::LITTLE_ENDIAN_DEFINE
        )
        .unwrap();
        writeln!(self.header_output, "{}#else", self.config.get_indent(1)).unwrap();
        writeln!(
            self.header_output,
            "{}#error \"Unsupported host endianness\"",
            self.config.get_indent(2)
        )
        .unwrap();
        writeln!(self.header_output, "{}#endif", self.config.get_indent(1)).unwrap();
        writeln!(
            self.header_output,
            "#elif defined(_WIN32) || defined(__LITTLE_ENDIAN__)"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}// Fallback for Windows (always little-endian) or other platforms",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(
            self.header_output,
            "{}#define {} {}",
            self.config.get_indent(1),
            Self::HOST_ENDIAN_DEFINE,
            Self::LITTLE_ENDIAN_DEFINE
        )
        .unwrap();
        writeln!(self.header_output, "#else").unwrap();
        writeln!(
            self.header_output,
            "{}#error \"Could not determine host endianness\"",
            self.config.get_indent(1)
        )
        .unwrap();
        writeln!(self.header_output, "#endif\n").unwrap();

        // --- 3. Byte Swap Functions (Explicit Overloads) ---
        let swap_types = vec![
            (
                "uint16_t",
                "int16_t",
                "((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF)",
            ),
            (
                "uint32_t",
                "int32_t",
                "(value << 24) | ((value & 0x00FF0000) >> 8) | ((value & 0x0000FF00) << 8) | (value >> 24)",
            ),
            (
                "uint64_t",
                "int64_t",
                "(value << 56) | ((value & 0x00FF000000000000ULL) >> 40) | ((value & 0x0000FF0000000000ULL) >> 24) | ((value & 0x000000FF00000000ULL) >> 8) | ((value & 0x00000000FF000000ULL) << 8) | ((value & 0x0000000000FF0000ULL) << 24) | ((value & 0x000000000000FF00ULL) << 40) | (value >> 56)",
            ),
        ];

        writeln!(
            self.header_output,
            "// Helper function to swap bytes (Explicit Overloads)"
        )
        .unwrap();

        for (u_type, i_type, logic) in &swap_types {
            // Unsigned Integers
            writeln!(
                self.header_output,
                "inline {u_type} byteswap({u_type} value) {{ return {logic}; }}\n"
            )
            .unwrap();

            // Signed Integers
            let i_logic = format!("({i_type})byteswap(({u_type})value)");
            writeln!(
                self.header_output,
                "inline {i_type} byteswap({i_type} value) {{ return {i_logic}; }}\n"
            )
            .unwrap();
        }

        let float_types = vec![("float", "uint32_t"), ("double", "uint64_t")];

        for (f_type, i_type) in float_types {
            writeln!(
                self.header_output,
                "inline {f_type} byteswap({f_type} value) {{"
            )
            .unwrap();
            writeln!(
                self.header_output,
                "{}{i_type} temp;",
                self.config.get_indent(1)
            )
            .unwrap();
            writeln!(
                self.header_output,
                "{}memcpy(&temp, &value, sizeof(value));",
                self.config.get_indent(1)
            )
            .unwrap();
            writeln!(
                self.header_output,
                "{}temp = byteswap(temp);",
                self.config.get_indent(1)
            )
            .unwrap();
            writeln!(
                self.header_output,
                "{}memcpy(&value, &temp, sizeof(value));",
                self.config.get_indent(1)
            )
            .unwrap();
            writeln!(
                self.header_output,
                "{}return value;",
                self.config.get_indent(1)
            )
            .unwrap();
            writeln!(self.header_output, "}}\n").unwrap();
        }

        // --- 4. Conditional Byte Swap Utility (Explicit Overloads) ---
        writeln!(
            self.header_output,
            "// Swaps bytes if the host order does not match the network order (Explicit Overloads)"
        )
        .unwrap();

        // Generate byteswap_if_needed for all multi-byte types
        for (cpp_type, _, _) in swap_types {
            writeln!(
                self.header_output,
                "inline {cpp_type} byteswap_if_needed({cpp_type} value) {{"
            )
            .unwrap();
            writeln!(
                self.header_output,
                "{}if ({} != {}) {{",
                self.config.get_indent(1),
                Self::HOST_ENDIAN_DEFINE,
                Self::NETWORK_ENDIAN_DEFINE
            )
            .unwrap();
            writeln!(
                self.header_output,
                "{}return byteswap(value);",
                self.config.get_indent(2)
            )
            .unwrap();
            writeln!(self.header_output, "{}}}", self.config.get_indent(1)).unwrap();
            writeln!(
                self.header_output,
                "{}return value;",
                self.config.get_indent(1)
            )
            .unwrap();
            writeln!(self.header_output, "}}\n").unwrap();
        }

        writeln!(self.header_output, "}} // namespace utils").unwrap();
    }
}

impl CodeGenerator for CppGenerator {
    fn generate(&mut self, module: &OnyxModule) -> Result<Vec<(PathBuf, String)>, CompileError> {
        self.header_output.clear();
        self.source_output.clear();

        let namespace = "onyx";

        self.write_header_includes();
        self.write_source_includes();

        writeln!(self.header_output, "namespace {namespace} {{").unwrap();
        writeln!(self.source_output, "namespace {namespace} {{\n").unwrap();

        self.write_endianness_utilities(&module.endianness);
        writeln!(self.header_output).unwrap();

        for id in &module.order {
            let def = match module.definitions.get(id) {
                Some(def) => def,
                None => {
                    return Err(CompileError(format!("expected to find type {id} in AST")));
                }
            };

            match def {
                Definition::Enum(e) => {
                    // Enums go entirely in the header
                    self.write_enum(e)?;
                    writeln!(self.header_output).unwrap();
                }
                Definition::Struct(s) => {
                    let struct_size = match s.size {
                        Some(struct_size) => struct_size.div_ceil(8),
                        None => {
                            return Err(CompileError(format!(
                                "expected {} to have size, found none",
                                s.name
                            )));
                        }
                    };
                    let groups = self.get_field_groups(&s.fields);
                    self.write_class_declaration(&s.name, &groups, module, struct_size);
                    writeln!(self.header_output).unwrap();
                    self.write_class_definition(module, &s.name, &groups);
                }
                Definition::Message(m) => {
                    let msg_size = match m.size {
                        Some(msg_size) => msg_size.div_ceil(8),
                        None => {
                            return Err(CompileError(format!(
                                "expected {} to have size, found none",
                                m.name
                            )));
                        }
                    };
                    let groups = self.get_field_groups(&m.fields);
                    self.write_class_declaration(&m.name, &groups, module, msg_size);
                    writeln!(self.header_output).unwrap();
                    self.write_class_definition(module, &m.name, &groups);
                }
            }
        }

        writeln!(self.header_output, "}} // namespace {namespace}").unwrap();
        writeln!(self.source_output, "}} // namespace {namespace}").unwrap();

        self.write_header_footer();

        Ok(vec![
            (
                self.file_path.with_extension("hpp"),
                self.header_output.clone(),
            ),
            (
                self.file_path.with_extension("cpp"),
                self.source_output.clone(),
            ),
        ])
    }
}
