use std::fmt::Write;

use crate::{
    ast::{Definition, EnumDef, Field, MessageDef, OnyxModule, PrimitiveType, StructDef, Type},
    generators::{CodeGenerator, CompileError},
}; // Used for efficient string building

pub struct CppGenerator {
    header_output: String,
    source_output: String,
    file_stem: String,
}

impl Default for CppGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl CppGenerator {
    pub fn new() -> Self {
        CppGenerator {
            header_output: String::new(),
            source_output: String::new(),
            file_stem: String::new(),
        }
    }

    /// Maps Onyx PrimitiveType to C++ type strings.
    fn map_primitive_type_to_cpp(&self, p: &PrimitiveType) -> &'static str {
        match p {
            PrimitiveType::Bool => "bool",
            PrimitiveType::U8 => "uint8_t",
            PrimitiveType::U16 => "uint16_t",
            PrimitiveType::U32 => "uint32_t",
            PrimitiveType::U64 => "uint64_t",
            PrimitiveType::I8 => "int8_t",
            PrimitiveType::I16 => "int16_t",
            PrimitiveType::I32 => "int32_t",
            PrimitiveType::I64 => "int64_t",
            PrimitiveType::F32 => "float",
            PrimitiveType::F64 => "double",
        }
    }

    /// Calculates the minimum expected byte size of an unpadded message/struct.
    fn calculate_message_size(&self, fields: &[Field]) -> Result<usize, CompileError> {
        let mut total_size = 0;
        for field in fields {
            // Note: This only calculates the minimum size based on primitive types.
            // It ignores padding (alignment) and custom types, which is acceptable
            // for raw IDL serialization where we assume packed data.
            if let Type::Primitive(p) = &field.type_info {
                total_size += p.get_byte_size();
            } else {
                // If a custom type is found, we can't reliably calculate size without a
                // symbol table, so we'll throw an error for this simple generator.
                return Err(CompileError(format!(
                    "Cannot calculate size for custom type '{}' without a symbol table for raw copy serialization.",
                    match &field.type_info {
                        Type::Custom(s) => s.as_str(),
                        _ => "Unknown",
                    }
                )));
            }
        }
        Ok(total_size)
    }

    fn write_header_includes(&mut self) {
        writeln!(
            self.header_output,
            "// Automatically generated by Onyx IDL compiler"
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#ifndef ONYX_{}_H_",
            self.file_stem.to_ascii_uppercase()
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#define ONYX_{}_H_\n",
            self.file_stem.to_ascii_uppercase()
        )
        .unwrap();
        writeln!(
            self.header_output,
            "#include <cstdint> // For fixed-size integers (uint8_t, etc.)"
        )
        .unwrap();
        writeln!(self.header_output, "#include <cstring> // For size_t\n").unwrap();
    }

    fn write_source_includes(&mut self) {
        writeln!(
            self.source_output,
            "// Automatically generated by Onyx IDL compiler"
        )
        .unwrap();
        writeln!(self.source_output, "#include \"{}.hpp\"", self.file_stem).unwrap();
        writeln!(self.source_output, "#include <cstring> // For memcpy").unwrap();
        writeln!(self.source_output).unwrap();
    }

    fn write_enum(&mut self, e: &EnumDef) -> Result<(), CompileError> {
        let underlying_type = self.map_primitive_type_to_cpp(&e.underlying_type);
        writeln!(
            self.header_output,
            "enum class {} : {} {{",
            e.name, underlying_type
        )
        .unwrap();

        let mut current_value: u64 = 0;
        for variant in &e.variants {
            let assigned_value = if let Some(val) = variant.value {
                current_value = val;
                format!(" = {val}")
            } else {
                let s = if current_value == 0 {
                    String::new()
                } else {
                    format!(" = {current_value}")
                };
                current_value += 1;
                s
            };
            writeln!(self.header_output, "  {}{},", variant.name, assigned_value).unwrap();
        }
        writeln!(self.header_output, "}};").unwrap();
        Ok(())
    }

    fn write_struct(&mut self, s: &StructDef) -> Result<(), CompileError> {
        writeln!(self.header_output, "struct {} {{", s.name).unwrap();
        for field in &s.fields {
            let type_str = match &field.type_info {
                Type::Primitive(p) => self.map_primitive_type_to_cpp(p).to_string(),
                Type::Custom(s) => s.clone(),
            };

            let bit_field_suffix = if let Some(bits) = field.bit_field_size {
                if bits > 0 {
                    format!(" : {bits}")
                } else {
                    String::new()
                }
            } else {
                String::new()
            };

            writeln!(
                self.header_output,
                "  {type_str} {name}{bit_field_suffix};",
                name = field.name,
            )
            .unwrap();
        }
        writeln!(self.header_output, "}};").unwrap();
        Ok(())
    }

    fn write_message_declaration(&mut self, m: &MessageDef) -> Result<(), CompileError> {
        writeln!(self.header_output, "class {} {{", m.name).unwrap();
        writeln!(self.header_output, "public:").unwrap();

        // Declare members (fields)
        for field in &m.fields {
            let type_str = match &field.type_info {
                Type::Primitive(p) => self.map_primitive_type_to_cpp(p).to_string(),
                Type::Custom(s) => s.clone(),
            };

            let bit_field_suffix = if let Some(bits) = field.bit_field_size {
                if bits > 0 {
                    format!(" : {bits}")
                } else {
                    String::new()
                }
            } else {
                String::new()
            };

            writeln!(
                self.header_output,
                "  {type_str} {name}{bit_field_suffix};",
                name = field.name,
            )
            .unwrap();
        }

        // Declare the static deserialization method
        writeln!(self.header_output).unwrap();
        writeln!(
            self.header_output,
            "  /// Attempts to deserialize {} from a raw buffer.",
            m.name
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  /// Assumes a packed memory layout (no alignment padding)."
        )
        .unwrap();
        writeln!(
            self.header_output,
            "  static {} Deserialize(const uint8_t* buffer, size_t size);",
            m.name
        )
        .unwrap();

        writeln!(self.header_output, "}};").unwrap();
        Ok(())
    }

    fn write_message_definition(
        &mut self,
        m: &MessageDef,
        namespace: &str,
    ) -> Result<(), CompileError> {
        let msg_size = self.calculate_message_size(&m.fields)?;
        let class_name = &m.name;

        // Implementation of the Deserialize method
        writeln!(self.source_output, "{namespace}::{class_name} {namespace}::{class_name}::Deserialize(const uint8_t* buffer, size_t size) {{").unwrap();

        writeln!(
            self.source_output,
            "  const size_t EXPECTED_SIZE = {msg_size};"
        )
        .unwrap();
        writeln!(self.source_output).unwrap();

        writeln!(self.source_output, "  if (size < EXPECTED_SIZE) {{").unwrap();
        writeln!(
            self.source_output,
            "    // In a production compiler, this would log to a proper framework."
        )
        .unwrap();
        writeln!(
            self.source_output,
            "    // For now, we'll use cerr and return nothing."
        )
        .unwrap();
        writeln!(self.source_output, "    std::cerr << \"[Onyx] Deserialize error: Buffer size (\" << size << \") is smaller than expected size (\" << EXPECTED_SIZE << \") for message {class_name}\" << std::endl;").unwrap();
        writeln!(self.source_output, "    return std::nullopt;").unwrap();
        writeln!(self.source_output, "  }}").unwrap();
        writeln!(self.source_output).unwrap();

        writeln!(self.source_output, "  {class_name} result;").unwrap();

        // Copy the raw bytes directly into the message object
        writeln!(self.source_output, "  memcpy(").unwrap();
        writeln!(
            self.source_output,
            "    &result,                // Destination"
        )
        .unwrap();
        writeln!(self.source_output, "    buffer,                 // Source").unwrap();
        writeln!(
            self.source_output,
            "    EXPECTED_SIZE           // Number of bytes (Note: assumes packed data!)"
        )
        .unwrap();
        writeln!(self.source_output, "  );").unwrap();
        writeln!(self.source_output).unwrap();

        writeln!(self.source_output, "  return result;").unwrap();
        writeln!(self.source_output, "}}").unwrap();
        writeln!(self.source_output).unwrap();

        Ok(())
    }
}

impl CodeGenerator for CppGenerator {
    fn generate(&mut self, module: &OnyxModule) -> Result<Vec<(String, String)>, CompileError> {
        self.header_output.clear();
        self.source_output.clear();

        self.write_header_includes();
        self.write_source_includes();

        let namespace = "onyx";

        // --- Write Header File (.hpp) Declarations ---
        writeln!(self.header_output, "namespace {namespace} {{\n").unwrap();
        writeln!(self.source_output, "namespace {namespace} {{\n").unwrap();

        for def in &module.definitions {
            match def {
                Definition::Enum(e) => {
                    // Enums go entirely in the header
                    self.write_enum(e)?;
                    writeln!(self.header_output).unwrap();
                }
                Definition::Struct(s) => {
                    // Structs go entirely in the header
                    self.write_struct(s)?;
                    writeln!(self.header_output).unwrap();
                }
                Definition::Message(m) => {
                    // Messages require both header (declaration) and source (definition)
                    self.write_message_declaration(m)?;
                    writeln!(self.header_output).unwrap();
                    self.write_message_definition(m, namespace)?;
                }
            }
        }

        writeln!(self.header_output, "}} // namespace {namespace}").unwrap();
        writeln!(self.source_output, "}} // namespace {namespace}").unwrap();

        Ok(vec![
            (
                format!("{}.hpp", self.file_stem).to_string(),
                self.header_output.clone(),
            ),
            (
                format!("{}.cpp", self.file_stem).to_string(),
                self.source_output.clone(),
            ),
        ])
    }
}
